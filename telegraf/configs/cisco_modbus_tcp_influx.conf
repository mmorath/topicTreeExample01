[global_tags]
[agent]
  interval = "10s"
  round_interval = true
  metric_batch_size = 1000
  metric_buffer_limit = 10000
  collection_jitter = "0s"
  flush_interval = "10s"
  flush_jitter = "0s"
  precision = "0s"
  hostname = ""
  omit_hostname = false
###############################################################################
#                            OUTPUT PLUGINS                                   #
###############################################################################
[[outputs.influxdb_v2]]
  urls = ["http://${DOCKER_INFLUXDB_INIT_HOST}:${DOCKER_INFLUXDB_INIT_PORT}"]
  token = "$DOCKER_INFLUXDB_INIT_ADMIN_TOKEN"
  organization = "$DOCKER_INFLUXDB_INIT_ORG"
  bucket = "$DOCKER_INFLUXDB_INIT_BUCKET"
###############################################################################
#                            AGGREGATOR PLUGINS                               #
###############################################################################

###############################################################################
#                            Processors PLUGINS                               #
###############################################################################
# --> https://github.com/influxdata/telegraf/tree/master/plugins/processors/enum
# Map enum values according to given table.
#[[processors.enum]]
#  [[processors.enum.mapping]]
    ## Name of the field to map. Globs accepted.
    # field = "status"

    ## Name of the tag to map. Globs accepted.
    # tag = "status"

    ## Destination tag or field to be used for the mapped value.  By default the
    ## source tag or field is used, overwriting the original value.
    #  dest = "status_code"

    ## Default value to be used for all values not contained in the mapping
    ## table.  When unset and no match is found, the original field will remain
    ## unmodified and the destination tag or field will not be created.
    # default = 0

    ## Table of mappings
    #    [processors.enum.mapping.value_mappings]
    #      green = 1
    #      amber = 2
    #      red = 3

    #powerSupplyState ={
    #    0x0 : "functional",
    #    0x2 : "not functional",
    #    0x3 : "is not recognized"
    #} 

    #alertState ={
    #    0x0 : "not asserted",
    #    0x2 : "asserted",
    #} 

    #high byte 
    #portInterfaceState ={
    #    0x0: "Interface is down",
    #    0x1: "Interface is going down",
    #    0x2: "Interface is in the initializing state",
    #    0x3: "Interface is coming up",
    #    0x4: "Interface is up and running",
    #    0x5: "Interface is reset by the user",
    #    0x6: "Interface is shut down by the user",
    #    0x7: "Interface is being deleted"

###############################################################################
#                            INPUT PLUGINS                                    #
###############################################################################
    ## Name of the measurement.
    ## Can be overriden by the individual field definitions. Defaults to "modbus"
    # measurement = "modbus"

    ## Field definitions
    ## Analog Variables, Input Registers and Holding Registers
    ## address        - address of the register to query. For coil and discrete inputs this is the bit address.
    ## name *1        - field name
    ## type *1,2      - type of the modbus field, can be INT16, UINT16, INT32, UINT32, INT64, UINT64 and
    ##                  FLOAT32, FLOAT64 (IEEE 754 binary representation)
    ## scale *1,2     - (optional) factor to scale the variable with
    ## output *1,2    - (optional) type of resulting field, can be INT64, UINT64 or FLOAT64. Defaults to FLOAT64 if
    ##                  "scale" is provided and to the input "type" class otherwise (i.e. INT* -> INT64, etc).
    ## measurement *1 - (optional) measurement name, defaults to the setting of the request
    ## omit           - (optional) omit this field. Useful to leave out single values when querying many registers
    ##                  with a single request. Defaults to "false".
    ##
    ## *1: Those fields are ignored if field is omitted ("omit"=true)
    ##
    ## *2: Thise fields are ignored for both "coil" and "discrete"-input type of registers. For those register types
    ##     the fields are output as zero or one in UINT64 format by default.

    ## Analog Variables, Input Registers and Holding Registers
    ## measurement - the (optional) measurement name, defaults to "modbus"
    ## name        - the variable name
    ## byte_order  - the ordering of bytes
    ##  |---AB, ABCD   - Big Endian
    ##  |---BA, DCBA   - Little Endian
    ##  |---BADC       - Mid-Big Endian
    ##  |---CDAB       - Mid-Little Endian
    ## data_type   - INT16, UINT16, INT32, UINT32, INT64, UINT64,
    ##               FLOAT32-IEEE, FLOAT64-IEEE (the IEEE 754 binary representation)
    ##               FLOAT32, FIXED, UFIXED (fixed-point representation on input)
    ## scale       - the final numeric variable representation
    ## address     - variable address

    ## Note for converting hex to dec use https://www.rapidtables.com/convert/number/hex-to-decimal.html?x=987%2C
    ## what can be read out from the switch can be found here https://www.cisco.com/c/en/us/td/docs/switches/lan/cisco_ie3X00/software/17_3/b_cip-modbus_17-3_iot_switch_cg/m_modbus.html
    ## Current downside of the agent...no text can be read out..which means the register 800 to 940 which hold the Product ID, Software Image Name, Hoste name and such cannot be read out...
    ## In order to interprete the port status you can use the enumeration plugin ..

[[inputs.modbus]]
  name = "Cisco_ie3300"
  slave_id = 1 
  timeout = "1s"
  controller = "tcp://192.168.178.95:502"
  #System Info Registers
  holding_registers = [
    { name = "system_temperature", byte_order = "AB",   data_type = "UINT16", scale=1.0,  address = [2440]},
    { name = "ps2_status", byte_order = "AB",   data_type = "UINT16", scale=1.0,  address = [2439]},
    { name = "ps1_status", byte_order = "AB",   data_type = "UINT16", scale=1.0,  address = [2438]},
    { name = "alarm_2_status", byte_order = "AB",   data_type = "UINT16", scale=1.0,  address = [2432]},
    { name = "alarm_1_status", byte_order = "AB",   data_type = "UINT16", scale=1.0,  address = [2433]},
    { name = "port_1_state", byte_order = "AB",   data_type = "UINT16", scale=1.0, address = [4736]},
    { name = "port_2_state", byte_order = "AB",   data_type = "UINT16", scale=1.0, address = [4737]},
    { name = "port_3_state", byte_order = "AB",   data_type = "UINT16", scale=1.0, address = [4738]},
    { name = "port_4_state", byte_order = "AB",   data_type = "UINT16", scale=1.0, address = [4739]},
    { name = "port_5_state", byte_order = "AB",   data_type = "UINT16", scale=1.0, address = [4740]},
    { name = "port_6_state", byte_order = "AB",   data_type = "UINT16", scale=1.0, address = [4741]},
    { name = "port_7_state", byte_order = "AB",   data_type = "UINT16", scale=1.0, address = [4742]},
    { name = "port_8_state", byte_order = "AB",   data_type = "UINT16", scale=1.0, address = [4743]},
    { name = "port_9_state", byte_order = "AB",   data_type = "UINT16", scale=1.0, address = [4744]},
    { name = "port_10_state", byte_order = "AB",   data_type = "UINT16", scale=1.0, address = [4745]},
  ]
###############################################################################
#                            OUTPUT FILE                                      #
###############################################################################
  [[outputs.file]]
  ## Files to parse each interval.  Accept standard unix glob matching rules,
  ## as well as ** to match recursive files and directories.
    files = ["./tmp/metrics.out"]
    data_format = "influx"
    rotation_interval = "24h"
    rotation_max_archives = 10  